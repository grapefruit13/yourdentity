# Frontend Development Rules for Cursor

이 파일은 프론트엔드 개발팀의 코드 컨벤션과 개발 가이드라인을 정의합니다.

## 코드 작성 원칙

### 1. 가독성 (Readability)

#### 매직 넘버 명명
- 매직 넘버는 반드시 명명된 상수로 대체하세요
```typescript
// ❌ Bad
await delay(300);

// ✅ Good
const ANIMATION_DELAY_MS = 300;
await delay(ANIMATION_DELAY_MS);
```

#### 구현 세부사항 추상화
- 복잡한 로직은 전용 컴포넌트나 HOC로 추상화하세요
- 인증 검사, 다이얼로그 로직 등은 별도 컴포넌트로 분리하세요

#### 조건부 렌더링 코드 경로 분리
- 역할별로 다른 UI/로직은 별도 컴포넌트로 분리하세요
```typescript
// ✅ Good
function SubmitButton() {
  const isViewer = useRole() === "viewer";
  return isViewer ? <ViewerSubmitButton /> : <AdminSubmitButton />;
}
```

#### 복잡한 삼항 연산자 단순화
- 복잡한 조건문은 IIFE나 if/else문으로 대체하세요
```typescript
// ✅ Good
const status = (() => {
  if (ACondition && BCondition) return "BOTH";
  if (ACondition) return "A";
  if (BCondition) return "B";
  return "NONE";
})();
```

#### 복잡한 조건 명명
- 복잡한 boolean 조건은 의미있는 변수명으로 할당하세요
```typescript
// ✅ Good
const isSameCategory = product.categories.some(category => category.id === targetCategory.id);
const isPriceInRange = product.prices.some(price => price >= minPrice && price <= maxPrice);
return isSameCategory && isPriceInRange;
```

### 2. 예측 가능성 (Predictability)

#### 반환 타입 표준화
- 유사한 함수/훅은 일관된 반환 타입을 사용하세요
```typescript
// ✅ Good - API 훅은 항상 Query 객체 반환
function useUser(): UseQueryResult<UserType, Error> {
  return useQuery({ queryKey: ["user"], queryFn: fetchUser });
}
```

#### 숨겨진 로직 노출 (단일 책임)
- 함수는 시그니처에서 암시하는 작업만 수행하세요
- 사이드 이펙트는 명시적으로 분리하세요

#### 고유하고 설명적인 이름 사용
- 커스텀 래퍼/함수는 모호함을 피하는 고유한 이름을 사용하세요
```typescript
// ✅ Good
export const httpService = {
  async getWithAuth(url: string) { /* ... */ }
};
```

### 3. 응집성 (Cohesion)

#### 폼 응집성 고려
- 필드 레벨 vs 폼 레벨 응집성을 요구사항에 맞게 선택하세요
- 독립적인 검증: 필드 레벨
- 관련된 필드들: 폼 레벨 (Zod 스키마 사용)

#### 기능/도메인별 코드 구성
- 코드 타입이 아닌 기능/도메인별로 디렉토리를 구성하세요
```
src/
├── shared/          # 공통 컴포넌트/훅/유틸
├── modules/
│   ├── community
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── api/
│   │   └── types/
│   └── store/
│       ├── components/
│       ├── hooks/
│       ├── api/
│       └── types/
```

### 4. 결합도 (Coupling)

#### 추상화와 결합도 균형
- 사용 사례가 분기할 가능성이 있다면 성급한 추상화를 피하세요
- 일부 중복을 허용하여 결합도를 낮추는 것이 나을 수 있습니다

#### 상태 관리 범위 제한
- 광범위한 상태 관리를 작고 집중된 훅/컨텍스트로 분해하세요
```typescript
// ✅ Good - 특정 목적의 훅
export function useCardIdQueryParam() {
  const [cardIdParam, setCardIdParam] = useQueryParam("cardId", NumberParam);
  return [cardIdParam ?? undefined, setCardId] as const;
}
```

#### Props Drilling 제거
- Props Drilling 대신 컴포넌트 컴포지션을 사용하세요

## TypeScript 컨벤션

### 타입 정의
- 인터페이스보다는 type을 우선적으로 사용하세요 (확장이 필요한 경우 제외)
- 유니온 타입을 적극 활용하세요
- Discriminated Union을 사용하여 타입 안정성을 확보하세요

```typescript
// ✅ Good
type ValidationResult = { ok: true } | { ok: false; reason: string };
```

### 제네릭 사용
- 재사용 가능한 컴포넌트/함수에는 적절한 제네릭을 사용하세요
- 제네릭 타입명은 의미있게 작성하세요 (T, K보다는 TData, TError 등)

## React 컨벤션

### 컴포넌트 작성
- 함수형 컴포넌트를 사용하세요
- 컴포넌트명은 PascalCase를 사용하세요
- Props 타입은 컴포넌트명 + Props로 명명하세요

```typescript
// ✅ Good
interface UserProfileCardProps {
  user: User;
  onEdit?: () => void;
}

function UserProfileCard({ user, onEdit }: UserProfileCardProps) {
  // ...
}
```

### 훅 사용
- 커스텀 훅은 use로 시작하세요
- 훅의 반환값은 배열이나 객체를 일관되게 사용하세요
- 의존성 배열을 정확히 명시하세요

### 상태 관리
- 로컬 상태는 useState 사용
- 전역 상태는 Zustand 사용
- React Query를 서버 상태 관리에 사용

## 스타일링 컨벤션

### Tailwind
- Tailwind CSS를 우선적으로 사용하세요
- 클래스명은 kebab-case 사용

### 반응형 디자인
- 모바일 퍼스트 접근법을 사용하세요
- Tailwind의 반응형 접두사를 적극 활용하세요

## 파일 및 폴더 구조

### 파일명 컨벤션
- 컴포넌트: PascalCase (UserProfile.tsx)
- 훅: camelCase (useUser.ts)
- 유틸리티: camelCase (formatDate.ts)
- 상수: _로 시작하는 소문자 (_options.ts)

### Import/Export 컨벤션
- Named export를 우선적으로 사용하세요
- Default export는 페이지 컴포넌트에만 사용
- 배럴 파일(index.ts)을 활용하여 깔끔한 import 구조 유지

```typescript
// ✅ Good
export { UserProfile } from './UserProfile';
export { useUser } from './useUser';
```

## 성능 최적화

### 메모이제이션
- React.memo는 필요한 경우에만 사용하세요
- useMemo, useCallback은 실제 성능 이슈가 있을 때만 사용
- 의존성 배열을 정확히 관리하세요

### 코드 스플리팅
- 페이지 단위로 lazy loading을 적용하세요
- 큰 라이브러리는 동적 import 사용

## 에러 처리

### 에러 바운더리
- 페이지 레벨에 에러 바운더리 설정
- 사용자 친화적인 에러 메시지 제공

### API 에러 처리
- React Query의 에러 처리 메커니즘 활용
- 전역 에러 처리 로직 구현

## 접근성 (a11y)

### 기본 원칙
- 시맨틱 HTML 사용
- ARIA 라벨 적절히 활용
- 키보드 네비게이션 지원
- 색상에만 의존하지 않는 UI 설계

## 코드 리뷰 체크리스트

### 필수 확인 사항
- [ ] 타입 안정성 확보
- [ ] 컴포넌트 단일 책임 원칙 준수
- [ ] Props drilling 최소화
- [ ] 적절한 에러 처리
- [ ] 성능 최적화 고려
- [ ] 접근성 고려

### 스타일 확인
- [ ] 일관된 코드 포맷팅 (Prettier)
- [ ] ESLint 규칙 준수
- [ ] 명명 규칙 일관성
- [ ] 주석의 적절성

## Next.js 15 & PWA 컨벤션

### App Router 사용
- App Router 구조를 준수하세요 (`app/` 디렉토리)
- 라우트 그룹 `(auth)`, `(main)` 등을 적절히 활용
- 서버 컴포넌트를 기본으로, 클라이언트 상호작용이 필요한 경우에만 `"use client"` 사용

```typescript
// ✅ Good - 서버 컴포넌트 우선
export default function Page() {
  return <div>Static content</div>;
}

// ✅ Good - 필요시에만 클라이언트 컴포넌트
"use client";
export default function InteractivePage() {
  const [state, setState] = useState();
  return <div>Interactive content</div>;
}
```

### PWA 최적화
- PWA 기능을 고려한 컴포넌트 설계
- 오프라인 상태 처리 로직 구현
- Service Worker와의 상호작용 고려
- 알림 권한 요청은 사용자 경험을 고려하여 적절한 타이밍에 실행

## Firebase 통합 컨벤션

### FCM (Firebase Cloud Messaging)
- 알림 권한 요청은 사용자 친화적으로 구현
- 포그라운드/백그라운드 알림 처리 분리
- 토큰 갱신 로직 구현
- 알림 클릭시 적절한 페이지로 라우팅

## UI 컴포넌트 시스템

### shadcn/ui 기반 컴포넌트
- shadcn/ui 컴포넌트를 기본으로 사용
- 커스텀 컴포넌트는 shadcn/ui 패턴을 따라 구현
- `cn()` 함수를 사용한 클래스명 병합 권장

```typescript
// ✅ Good - shadcn/ui 패턴 따르기
interface CustomButtonProps extends React.ComponentProps<"button"> {
  variant?: "default" | "destructive" | "outline";
  size?: "default" | "sm" | "lg";
}

function CustomButton({ className, variant = "default", ...props }: CustomButtonProps) {
  return (
    <button
      className={cn(buttonVariants({ variant }), className)}
      {...props}
    />
  );
}
```

### Class Variance Authority (CVA) 활용
- 컴포넌트 variant 관리에 CVA 사용
- 타입 안전성을 위해 `VariantProps` 활용
- 기본값 설정으로 안정성 확보

## 환경 변수 및 설정 관리

### 환경 변수 네이밍
- Next.js 환경 변수는 `NEXT_PUBLIC_` 접두사 사용 (클라이언트 노출시)
- Firebase 관련 환경 변수는 명확한 네이밍 사용
- 타입 안전성을 위해 환경 변수 타입 정의

```typescript
// ✅ Good - 환경 변수 타입 정의
interface EnvironmentVariables {
  NEXT_PUBLIC_FIREBASE_API_KEY: string;
  NEXT_PUBLIC_FIREBASE_PROJECT_ID: string;
  // ...
}
```

## 디버깅 및 로깅

### Debug 유틸리티 활용
- 프로젝트의 debug 유틸리티를 일관되게 사용
- 개발/프로덕션 환경별 로깅 레벨 관리
- 에러 로깅시 충분한 컨텍스트 정보 포함

```typescript
// ✅ Good - 일관된 디버깅
import { debug } from '@/shared/utils/debugger';

debug.log('정보성 로그');
debug.warn('경고 메시지');
debug.error('에러 발생:', error);
```

## 모바일 최적화

### 터치 인터페이스 고려
- 터치 타겟 크기 최소 44px 확보
- 스와이프, 터치 제스처 지원
- 모바일 키보드 대응 (viewport 조정 등)

### 반응형 디자인 원칙
- 모바일 퍼스트 접근법 준수
- Tailwind의 반응형 클래스 적극 활용
- 다양한 화면 크기 대응 (특히 모바일 splash 화면들)

## 성능 최적화 (PWA 특화)

### 이미지 최적화
- Next.js Image 컴포넌트 사용
- WebP, AVIF 포맷 활용 (next.config.ts 설정 준수)
- 적절한 이미지 크기 및 해상도 제공

### 캐싱 전략
- Service Worker 캐싱 전략 활용
- 정적 리소스와 API 응답 캐싱 분리
- 오프라인 대비 필수 리소스 캐싱

## 코드 품질 도구

### Linting & Formatting
- ESLint 규칙 준수 (`npm run lint`)
- Prettier를 통한 일관된 포맷팅
- lint-staged를 통한 커밋 전 검사

### 타입 안전성
- TypeScript strict 모드 활용
- 환경 변수, API 응답 등 모든 외부 데이터 타입 정의
- any 타입 사용 최소화 (불가피한 경우 주석으로 이유 명시)

이 규칙들을 준수하여 유지보수 가능하고 확장성 있는 프론트엔드 코드를 작성해주세요.


